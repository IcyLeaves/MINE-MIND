# 动态规划(DP)

*summary*

**动态规划**是一个极其常用的算法

---

*pinned*

### 动态规划介绍

首先，来看一个最经典、最简单的例子

> [1137. 第 N 个泰波那契数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

$$
T(n+3)=T(n)+T(n+1)+T(n+2)
$$

如果直接使用递归，由于每一项都会展开成三项，使得时间复杂度呈指数级上升。而这个究其原因是没有很好的利用之前算过的值，又重新计算了很多次导致的。

于是，我们想到把一些重要的过程值存储下来，方便之后的计算使用。在这道题里面，我们直接使用循环，然后分别存储**前三项的值**，在新的结果出现后，**重新滚动赋值**，得出新的状态值。

```cpp
for (int i = 3; i <= n; ++i) {
    //状态转移
    p = q;
    q = r;
    r = s;
    //计算
    s = p + q + r;
}
```

- 空间花费：前三项的值。
- 状态转移：重新滚动赋值

#### 子序列预处理

> [392. 判断子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/is-subsequence/)

- 问题定义：判断字符串s是否为字符串t的子序列。额外要求是必须对字符串t进行预处理，以加快判断速度。

- 空间花费：二维dp数组。`dp[i][j]`代表字符`t[i]`之后`'a'+j`第一次出现的下标。
  - 为什么会使用这个数组？因为我们在判断子序列时会使用双指针，但其实双指针的移动距离不同，字符串t的字母相对较多，它的指针会移动很长的无效距离，而这仅仅是为了找到下一个匹配的符号位置（包括此处）。所以我们如果预先知道这个位置，就会节省很多时间。
  
  - 比如`aba`的dp数组如下
  
    |           | `dp[]['a']` | `dp[]['b']` |
    | --------- | ----------- | ----------- |
    | `dp[0][]` | 0           | 1           |
    | `dp[1][]` | 2           | 1           |
    | `dp[2][]` | 2           | X           |
  
  - 问题1：如何表示X？
  
  - 问题2：`dp[1]['a']`是怎么知道之后的b是2呢？
  
- 问题1：

  - 设置一个超出下标边界的固定值，比如`X=3`

- 问题2：

  - 既然整个数组需要知道之后的信息，我们就从后面开始遍历即可。

- 状态转移：

  - 每次循环会对当前位置进行遍历，`dp[n]['a']~dp[n]['z']`
  - 如果字符正好就在这个位置，那么就更新当前位置：`dp[n][nowChar]=n`
  - 其他25种情况，就沿用上一次位置的值：`dp[n][nowChar]=dp[n+1][nowChar]`

> 应用预处理dp数组：依次遍历字符串s的字符，如果碰到`dp[x][s[i]-'a']==X`，就说明该位置及以后都没能找到对应字符，即匹配失败；否则就跳转到对应的位置**+1**。



---

*2021.07.30*

> [面试题 16.17. 连续数列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/contiguous-sequence-lcci/)

---

*2022.02.19*

### LCS 最长公共子序列

> [1035. 不相交的线 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/uncrossed-lines/)
>
> [1143. 最长公共子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-common-subsequence/)

### LIS 最长递增子序列

> [300. 最长递增子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
>
> [面试题 17.08. 马戏团人塔 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/circus-tower-lcci/)

---

*2022.02.28*

### 从这么一道题聊DP

> [375. 猜数字大小 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)

#### 递归的前提——分析子问题

子问题有一些特点：

- 独立于其他子问题：相当于可以完全抛弃其他数据，利用更小的局部数据重新的开一道题目，依旧能得出子问题的解（解可能会依赖于更小的子问题）。
- 最小子问题有解：当子问题不能拆分或已经足够小时，可以直接得出答案。

此题的子问题显而易见，每当我们猜一个数后，出题人会告诉我们三种可能的结果

- 答案大于此数：那么答案就会落到这个数的右侧区间
- 答案小于此数：答案就会落到这个数的左侧区间
- 答案等于此数：赢得游戏

进一步推理：因为题目要求的是无论答案为多少的最坏情况，所以我们可以假设答案落在了最不利游戏获胜的位置，因此就是要让玩家猜错，而且是错在了最亏的一个区间。

我们要选好分割的点，让我们就算最亏，也是亏的最少。用公式来表达就是
$$
cost(x)=x+\max (f(1, x-1), f(x+1, n))\
$$

$$
f(1, n)=\min _{1 \leq x \leq n}\{cost(x)\}=\min _{1 \leq x \leq n}\{x+\max (f(1, x-1), f(x+1, n))\}
$$

#### 最小子问题——递归的出口

如果用$f(i,j)$代表$[i,j]$的最小花费金额，根据区间长度可以得出两种特殊情况

- **长度为1**：$i=j$，此时一定能猜对，所以$f(i,j)=0$
- **长度小于1**：$i>=j$，指的是区间无效，这种情况下也是$f(i,j)=0$

#### 记忆化——起点与终点

动态规划的一个状态就是上述的一个子问题，而状态转移其实就是根据一个规模较小的子问题，**往大的方向计算了一步**，求解出了一个大的问题。动态规划结束的地方，就是我们利用无数小问题求解出了整个原问题的时候。

我们继续回到刚才的递归公式，假如现在把边界从$[1,n]$改成$[i,j]$，并且i和j并不满足最小子问题的条件。其实就得到了状态转移公式。

因此我们从最小子问题的已知解$[n,n]\rightarrow0$开始，努力去求解原问题$[1,n]\rightarrow?$
$$
f(i, j)=\min _{i \leq k \leq j}\{k+\max (f(i, k-1), f(k+1, j))\}
$$

#### 遍历的方向

从状态方程我们可以看出，我们要 求解出一个$f(i,j)$，就需要知道$f(i,i-1),f(i,i),f(i,i+1)...f(i,j-1)$和$f(i+1,j),f(i+2,j)...f(j+1,j)$，如果在二维的dp矩阵中就是在此行的左侧和在此列的下侧。

由于我们之前的分析，我们可以将矩阵的左下半的矩阵全部置为0$(i>=j)$，因此我们的k就可以从i遍历到j
