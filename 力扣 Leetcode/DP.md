# 动态规划(DP)

*summary*

**动态规划**是一个极其常用的算法

---

*pinned*

### 动态规划介绍

首先，来看一个最经典、最简单的例子

> [1137. 第 N 个泰波那契数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

$$
T(n+3)=T(n)+T(n+1)+T(n+2)
$$

如果直接使用递归，由于每一项都会展开成三项，使得时间复杂度呈指数级上升。而这个究其原因是没有很好的利用之前算过的值，又重新计算了很多次导致的。

于是，我们想到把一些重要的过程值存储下来，方便之后的计算使用。在这道题里面，我们直接使用循环，然后分别存储**前三项的值**，在新的结果出现后，**重新滚动赋值**，得出新的状态值。

```cpp
for (int i = 3; i <= n; ++i) {
    //状态转移
    p = q;
    q = r;
    r = s;
    //计算
    s = p + q + r;
}
```

- 空间花费：前三项的值。
- 状态转移：重新滚动赋值

#### 子序列预处理

> [392. 判断子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/is-subsequence/)

- 问题定义：判断字符串s是否为字符串t的子序列。额外要求是必须对字符串t进行预处理，以加快判断速度。

- 空间花费：二维dp数组。`dp[i][j]`代表字符`t[i]`之后`'a'+j`第一次出现的下标。
  - 为什么会使用这个数组？因为我们在判断子序列时会使用双指针，但其实双指针的移动距离不同，字符串t的字母相对较多，它的指针会移动很长的无效距离，而这仅仅是为了找到下一个匹配的符号位置（包括此处）。所以我们如果预先知道这个位置，就会节省很多时间。
  
  - 比如`aba`的dp数组如下
  
    |           | `dp[]['a']` | `dp[]['b']` |
    | --------- | ----------- | ----------- |
    | `dp[0][]` | 0           | 1           |
    | `dp[1][]` | 2           | 1           |
    | `dp[2][]` | 2           | X           |
  
  - 问题1：如何表示X？
  
  - 问题2：`dp[1]['a']`是怎么知道之后的b是2呢？
  
- 问题1：

  - 设置一个超出下标边界的固定值，比如`X=3`

- 问题2：

  - 既然整个数组需要知道之后的信息，我们就从后面开始遍历即可。

- 状态转移：

  - 每次循环会对当前位置进行遍历，`dp[n]['a']~dp[n]['z']`
  - 如果字符正好就在这个位置，那么就更新当前位置：`dp[n][nowChar]=n`
  - 其他25种情况，就沿用上一次位置的值：`dp[n][nowChar]=dp[n+1][nowChar]`

> 应用预处理dp数组：依次遍历字符串s的字符，如果碰到`dp[x][s[i]-'a']==X`，就说明该位置及以后都没能找到对应字符，即匹配失败；否则就跳转到对应的位置**+1**。

*2021.07.30*

> [面试题 16.17. 连续数列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/contiguous-sequence-lcci/)

---

